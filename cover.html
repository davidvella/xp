
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>compactor: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/davidvella/xp/core/compactor/compactor.go (80.0%)</option>
				
				<option value="file1">github.com/davidvella/xp/core/loser/loser.go (92.0%)</option>
				
				<option value="file2">github.com/davidvella/xp/core/partition/partition.go (100.0%)</option>
				
				<option value="file3">github.com/davidvella/xp/core/partition/strategy/composite/composite.go (100.0%)</option>
				
				<option value="file4">github.com/davidvella/xp/core/partition/strategy/messagecount/messagecount.go (100.0%)</option>
				
				<option value="file5">github.com/davidvella/xp/core/partition/strategy/timewindow/timewindow.go (100.0%)</option>
				
				<option value="file6">github.com/davidvella/xp/core/priority/queue.go (83.1%)</option>
				
				<option value="file7">github.com/davidvella/xp/core/processor/processor.go (88.2%)</option>
				
				<option value="file8">github.com/davidvella/xp/core/recordio/recordio.go (85.9%)</option>
				
				<option value="file9">github.com/davidvella/xp/core/storage/local/local.go (86.7%)</option>
				
				<option value="file10">github.com/davidvella/xp/core/wal/wal.go (88.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package compactor

import (
        "io"
        "time"

        "github.com/davidvella/xp/core/loser"
        "github.com/davidvella/xp/core/partition"
        "github.com/davidvella/xp/core/recordio"
)

var (
        // Create a string with the maximum Unicode code point (U+10FFFF).
        maxPossibleString = "\U0010FFFF"
        // The max time that can be represented.
        maxTime   = time.Date(292277026596, 12, 4, 15, 30, 7, 999999999, time.UTC)
        maxRecord = partition.RecordImpl{
                ID:           maxPossibleString,
                PartitionKey: maxPossibleString,
                // The max time that can be represented
                Timestamp: maxTime,
        }
)

// Compact performs streaming compaction of multiple sequences using a loser tree.
func Compact(w io.Writer, sequences ...loser.Sequence[partition.Record]) error <span class="cov6" title="2">{
        if len(sequences) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="2">var (
                lt   = loser.New[partition.Record](sequences, maxRecord)
                last partition.Record
                done bool
        )

        for current := range lt.All() </span><span class="cov10" title="3">{
                if current == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="3">if !done </span><span class="cov1" title="1">{
                        last = current
                        done = true
                        continue</span>
                }
                <span class="cov6" title="2">if last != nil &amp;&amp; current.GetID() != last.GetID() </span><span class="cov1" title="1">{
                        err := recordio.Write(w, last)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov6" title="2">last = current</span>
        }

        <span class="cov6" title="2">if done </span><span class="cov1" title="1">{
                err := recordio.Write(w, last)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov6" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package loser Taken from talk: https://github.com/bboreham/go-loser/blob/iter/tree.go.
// Thank you Bryan
package loser

import (
        "iter"
)

type Lesser[T any] interface {
        Less(T) bool
}

type Sequence[E Lesser[E]] interface {
        All() iter.Seq[E]
}

func New[E Lesser[E]](sequences []Sequence[E], maxVal E) *Tree[E] <span class="cov5" title="8">{
        t := Tree[E]{
                maxVal:    maxVal,
                nodes:     make([]node[E], len(sequences)*2),
                sequences: sequences,
        }
        return &amp;t
}</span>

// A loser tree is a binary tree laid out such that nodes N and N+1 have parent N/2.
// We store M leaf nodes in positions M...2M-1, and M-1 internal nodes in positions 1..M-1.
// Node 0 is a special node, containing the winner of the contest.
type Tree[E Lesser[E]] struct {
        maxVal    E
        nodes     []node[E]
        sequences []Sequence[E]
}

type node[E Lesser[E]] struct {
        index int              // This is the loser for all nodes except the 0th, where it is the winner.
        value E                // Value copied from the loser node, or winner for node 0.
        next  func() (E, bool) // Only populated for leaf nodes.
}

func (t *Tree[E]) moveNext(index int) bool <span class="cov9" title="42">{
        n := &amp;t.nodes[index]
        if v, ok := n.next(); ok </span><span class="cov8" title="28">{
                n.value = v
                return true
        }</span>
        <span class="cov6" title="14">n.value = t.maxVal
        n.index = -1
        return false</span>
}

func (t *Tree[E]) All() iter.Seq[E] <span class="cov5" title="8">{
        return func(yield func(E) bool) </span><span class="cov5" title="8">{
                if len(t.nodes) == 0 </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov5" title="7">for i, s := range t.sequences </span><span class="cov6" title="14">{
                        next, stop := iter.Pull(s.All())
                        t.nodes[i+len(t.sequences)].next = next
                        //nolint:gocritic // is not a leak.
                        defer stop()
                        t.moveNext(i + len(t.sequences)) // Call next() on each item to get the first value.
                }</span>
                <span class="cov5" title="7">t.initialize()
                for t.nodes[t.nodes[0].index].index != -1 &amp;&amp;
                        yield(t.nodes[0].value) </span><span class="cov8" title="28">{
                        t.moveNext(t.nodes[0].index)
                        t.replayGames(t.nodes[0].index)
                }</span>
        }
}

func (t *Tree[E]) IsEmpty() bool <span class="cov0" title="0">{
        nodes := t.nodes
        if nodes[0].index == -1 </span><span class="cov0" title="0">{ // If tree has not been initialized yet, do that.
                t.initialize()
        }</span>
        <span class="cov0" title="0">return nodes[nodes[0].index].index == -1</span>
}

func (t *Tree[E]) initialize() <span class="cov5" title="7">{
        winner := t.playGame(1)
        t.nodes[0].index = winner
        t.nodes[0].value = t.nodes[winner].value
}</span>

// Find the winner at position pos; if it is a non-leaf node, store the loser.
// pos must be &gt;= 1 and &lt; len(t.nodes).
func (t *Tree[E]) playGame(pos int) int <span class="cov7" title="21">{
        nodes := t.nodes
        if pos &gt;= len(nodes)/2 </span><span class="cov6" title="14">{
                return pos
        }</span>
        <span class="cov5" title="7">left := t.playGame(pos * 2)
        right := t.playGame(pos*2 + 1)
        var loser, winner int
        if nodes[left].value.Less(nodes[right].value) </span><span class="cov4" title="4">{
                loser, winner = right, left
        }</span> else<span class="cov3" title="3"> {
                loser, winner = left, right
        }</span>
        <span class="cov5" title="7">nodes[pos].index = loser
        nodes[pos].value = nodes[loser].value
        return winner</span>
}

// Starting at pos, which is a winner, re-consider all values up to the root.
func (t *Tree[E]) replayGames(pos int) <span class="cov8" title="28">{
        nodes := t.nodes
        winningValue := nodes[pos].value
        for n := parent(pos); n != 0; n = parent(n) </span><span class="cov8" title="27">{
                node := &amp;nodes[n]
                if node.value.Less(winningValue) </span><span class="cov5" title="9">{
                        // Record pos as the loser here, and the old loser is the new winner.
                        node.index, pos = pos, node.index
                        node.value, winningValue = winningValue, node.value
                }</span>
        }
        // pos is now the winner; store it in node 0.
        <span class="cov8" title="28">nodes[0].index = pos
        nodes[0].value = winningValue</span>
}

func parent(i int) int <span class="cov10" title="55">{ return i &gt;&gt; 1 }</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package partition

import (
        "cmp"
        "time"
)

type RecordImpl struct {
        ID           string
        PartitionKey string
        Timestamp    time.Time
        Data         []byte
}

func (r RecordImpl) GetID() string <span class="cov8" title="44">{
        return r.ID
}</span>

func (r RecordImpl) GetPartitionKey() string <span class="cov8" title="50">{
        return r.PartitionKey
}</span>

func (r RecordImpl) GetWatermark() time.Time <span class="cov10" title="103">{
        return r.Timestamp
}</span>

func (r RecordImpl) GetData() []byte <span class="cov8" title="38">{
        return r.Data
}</span>

func (r RecordImpl) Less(t Record) bool <span class="cov3" title="4">{
        if c := cmp.Compare(r.PartitionKey, t.GetPartitionKey()); c &lt; 0 </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov3" title="3">if c := cmp.Compare(r.ID, t.GetID()); c &lt; 0 </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov2" title="2">if c := r.Timestamp.Compare(t.GetWatermark()); c &lt; 0 </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov1" title="1">return false</span>
}

type Record interface {
        Less(t Record) bool
        GetID() string
        GetPartitionKey() string
        GetWatermark() time.Time
        GetData() []byte
}

type Strategy interface {
        ShouldRotate(information Information, watermark time.Time) bool
}

type Information struct {
        PartitionKey   string
        RecordCount    int
        FirstWatermark time.Time
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package composite

import (
        "time"

        "github.com/davidvella/xp/core/partition"
)

var _ partition.Strategy = &amp;Strategy{}

type Strategy struct {
        partitions []partition.Strategy
}

func NewStrategy(partitions ...partition.Strategy) *Strategy <span class="cov8" title="7">{
        return &amp;Strategy{partitions: partitions}
}</span>

func (c *Strategy) ShouldRotate(information partition.Information, t time.Time) bool <span class="cov8" title="7">{
        for _, p := range c.partitions </span><span class="cov10" title="9">{
                if rotate := p.ShouldRotate(information, t); rotate </span><span class="cov6" title="4">{
                        return rotate
                }</span>
        }
        <span class="cov5" title="3">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package messagecount

import (
        "time"

        "github.com/davidvella/xp/core/partition"
)

type Strategy struct {
        MaxMessages int
}

func NewStrategy(maxMessages int) *Strategy <span class="cov10" title="5">{
        return &amp;Strategy{
                MaxMessages: maxMessages,
        }
}</span>

func (s *Strategy) ShouldRotate(information partition.Information, _ time.Time) bool <span class="cov10" title="5">{
        return information.RecordCount &gt;= s.MaxMessages
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package timewindow

import (
        "time"

        "github.com/davidvella/xp/core/partition"
)

type Strategy struct {
        windowSize time.Duration
}

func NewStrategy(windowSize time.Duration) *Strategy <span class="cov10" title="2">{
        return &amp;Strategy{
                windowSize: windowSize,
        }
}</span>

func (s *Strategy) ShouldRotate(information partition.Information, watermark time.Time) bool <span class="cov10" title="2">{
        return watermark.Sub(information.FirstWatermark) &gt; s.windowSize
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package priority

// item represents an item in the value queue.
type item[K comparable, V any] struct {
        key   K
        value V
        index int
}

// Queue implements a value queue using a heap.
type Queue[K comparable, V any] struct {
        items   []*item[K, V]
        itemMap map[K]*item[K, V]
        lessF   func(a, b V) bool // returns true if a has higher priority than b
}

// NewQueue creates a new priority queue with the given comparator.
func NewQueue[K comparable, P any](less func(a, b P) bool) *Queue[K, P] <span class="cov5" title="6">{
        return &amp;Queue[K, P]{
                items:   make([]*item[K, P], 0),
                itemMap: make(map[K]*item[K, P]),
                lessF:   less,
        }
}</span>

// Len returns the number of items in the queue.
func (pq *Queue[K, V]) Len() int <span class="cov7" title="11">{
        return len(pq.items)
}</span>

// Get adds a new key or updates an existing key's value.
func (pq *Queue[K, V]) Get(key K) (V, bool) <span class="cov0" title="0">{
        i, exists := pq.itemMap[key]
        if !exists </span><span class="cov0" title="0">{
                var zeroP V
                return zeroP, exists
        }</span>
        <span class="cov0" title="0">return i.value, exists</span>
}

// Set adds a new key or updates an existing key's value.
func (pq *Queue[K, V]) Set(key K, value V) <span class="cov8" title="16">{
        if i, exists := pq.itemMap[key]; exists </span><span class="cov1" title="1">{
                oldValue := i.value
                i.value = value
                if pq.lessF(value, oldValue) </span><span class="cov1" title="1">{
                        pq.up(i.index)
                }</span> else<span class="cov0" title="0"> {
                        pq.down(i.index)
                }</span>
        } else<span class="cov8" title="15"> {
                i := &amp;item[K, V]{
                        key:   key,
                        value: value,
                        index: len(pq.items),
                }
                pq.items = append(pq.items, i)
                pq.itemMap[key] = i
                pq.up(i.index)
        }</span>
}

// Remove removes the given key from the queue.
func (pq *Queue[K, V]) Remove(key K) <span class="cov6" title="8">{
        i, exists := pq.itemMap[key]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="8">idx := i.index
        lastIdx := len(pq.items) - 1

        if idx != lastIdx </span><span class="cov6" title="7">{
                pq.swap(idx, lastIdx)
                pq.items = pq.items[:lastIdx]
                if idx &lt; lastIdx </span><span class="cov6" title="7">{
                        pq.down(idx)
                        pq.up(idx)
                }</span>
        } else<span class="cov1" title="1"> {
                pq.items = pq.items[:lastIdx]
        }</span>

        <span class="cov6" title="8">delete(pq.itemMap, key)</span>
}

// Pop removes and returns the highest priority item.
func (pq *Queue[K, V]) Pop() (key K, value V, exists bool) <span class="cov6" title="8">{
        if len(pq.items) == 0 </span><span class="cov1" title="1">{
                var zeroK K
                var zeroP V
                return zeroK, zeroP, false
        }</span>

        <span class="cov6" title="7">i := pq.items[0]
        pq.Remove(i.key)
        return i.key, i.value, true</span>
}

// Peek returns the highest priority item without removing it.
func (pq *Queue[K, V]) Peek() (key K, value V, exists bool) <span class="cov4" title="4">{
        if len(pq.items) == 0 </span><span class="cov0" title="0">{
                var zeroK K
                var zeroP V
                return zeroK, zeroP, false
        }</span>
        <span class="cov4" title="4">i := pq.items[0]
        return i.key, i.value, true</span>
}

// swap swaps items at index i and j.
func (pq *Queue[K, V]) swap(i, j int) <span class="cov8" title="18">{
        pq.items[i], pq.items[j] = pq.items[j], pq.items[i]
        pq.items[i].index = i
        pq.items[j].index = j
}</span>

// less compares items at index i and j.
func (pq *Queue[K, V]) less(i, j int) bool <span class="cov8" title="19">{
        return pq.lessF(pq.items[i].value, pq.items[j].value)
}</span>

// up moves the element at index i up to its proper position.
func (pq *Queue[K, V]) up(i int) <span class="cov9" title="23">{
        for </span><span class="cov10" title="29">{
                parent := (i - 1) / 2
                if parent == i || !pq.less(i, parent) </span><span class="cov9" title="23">{
                        break</span>
                }
                <span class="cov5" title="6">pq.swap(i, parent)
                i = parent</span>
        }
}

// down moves the element at index i down to its proper position.
func (pq *Queue[K, V]) down(i int) <span class="cov6" title="7">{
        for </span><span class="cov7" title="12">{
                smallest := i
                left := 2*i + 1
                right := 2*i + 2

                if left &lt; len(pq.items) &amp;&amp; pq.less(left, smallest) </span><span class="cov5" title="5">{
                        smallest = left
                }</span>
                <span class="cov7" title="12">if right &lt; len(pq.items) &amp;&amp; pq.less(right, smallest) </span><span class="cov0" title="0">{
                        smallest = right
                }</span>

                <span class="cov7" title="12">if smallest == i </span><span class="cov6" title="7">{
                        break</span>
                }

                <span class="cov5" title="5">pq.swap(i, smallest)
                i = smallest</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package processor

import (
        "context"
        "fmt"
        "io"
        "sync"
        "time"

        "github.com/davidvella/xp/core/partition"
        "github.com/davidvella/xp/core/priority"
        "github.com/davidvella/xp/core/storage"
        "github.com/davidvella/xp/core/wal"
)

type Processor struct {
        storage     storage.Storage
        strategy    partition.Strategy
        mu          sync.RWMutex
        activeFiles *priority.Queue[string, activeWriter]
}

type activeWriter struct {
        mu            *sync.RWMutex
        writer        *wal.WAL
        information   partition.Information
        name          string
        lastWatermark time.Time
}

func newActiveWriter(writer io.WriteCloser, record partition.Record, name string) activeWriter <span class="cov7" title="5">{
        return activeWriter{
                writer: wal.NewWAL(writer),
                information: partition.Information{
                        PartitionKey:   record.GetPartitionKey(),
                        RecordCount:    0,
                        FirstWatermark: record.GetWatermark(),
                },
                lastWatermark: record.GetWatermark(),
                mu:            &amp;sync.RWMutex{},
                name:          name,
        }
}</span>

func (w *activeWriter) Write(rec partition.Record) error <span class="cov8" title="6">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if err := w.writer.Write(rec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">w.lastWatermark = rec.GetWatermark()
        w.information.RecordCount++

        return nil</span>
}

func (w *activeWriter) Close() error <span class="cov3" title="2">{
        w.mu.Lock()
        defer w.mu.Unlock()

        return w.writer.Close()
}</span>

func New(storage storage.Storage, strategy partition.Strategy) *Processor <span class="cov9" title="8">{
        return &amp;Processor{
                storage:     storage,
                strategy:    strategy,
                activeFiles: priority.NewQueue[string, activeWriter](orderByWatermark),
        }
}</span>

func (w *Processor) Handle(ctx context.Context, record partition.Record) error <span class="cov8" title="7">{
        w.mu.RLock()

        partitionKey := record.GetPartitionKey()
        active, exists := w.activeFiles.Get(partitionKey)
        shouldRotate := !exists || w.strategy.ShouldRotate(active.information, record.GetWatermark())

        w.mu.RUnlock()

        if shouldRotate </span><span class="cov8" title="6">{
                var err error
                if active, err = w.getActiveWriter(ctx, record, partitionKey); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="6">if err := active.Write(record); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write: %w", err)
        }</span>

        <span class="cov8" title="6">w.activeFiles.Set(partitionKey, active)

        if err := w.cleanup(ctx, record.GetWatermark()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">return nil</span>
}

func (w *Processor) Close(ctx context.Context) error <span class="cov3" title="2">{
        w.mu.Lock()
        defer w.mu.Unlock()

        for </span><span class="cov5" title="3">{
                k, _, ok := w.activeFiles.Pop()
                if !ok </span><span class="cov3" title="2">{
                        break</span>
                }
                <span class="cov1" title="1">if err := w.rotate(ctx, k); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to rotate during close: %w", err)
                }</span>
        }

        <span class="cov3" title="2">return nil</span>
}

func (w *Processor) Recover(ctx context.Context) error <span class="cov3" title="2">{
        files, err := w.storage.List(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to list pending files: %w", err)
        }</span>

        <span class="cov1" title="1">for _, file := range files </span><span class="cov3" title="2">{
                if err := w.storage.Publish(ctx, file); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to publish recovered file: %w", err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (w *Processor) getActiveWriter(ctx context.Context, record partition.Record, partitionKey string) (activeWriter, error) <span class="cov8" title="6">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if err := w.rotate(ctx, partitionKey); err != nil </span><span class="cov0" title="0">{
                return activeWriter{}, fmt.Errorf("failed to rotate: %w", err)
        }</span>

        <span class="cov8" title="6">writerName := fmt.Sprintf("%s_%d.dat", partitionKey, record.GetWatermark().Unix())
        writer, err := w.storage.Create(ctx, writerName)
        if err != nil </span><span class="cov1" title="1">{
                return activeWriter{}, fmt.Errorf("failed to create writer: %w", err)
        }</span>

        <span class="cov7" title="5">active := newActiveWriter(writer, record, writerName)

        w.activeFiles.Set(partitionKey, active)

        return active, nil</span>
}

func (w *Processor) rotate(ctx context.Context, partitionKey string) error <span class="cov10" title="9">{
        active, found := w.activeFiles.Get(partitionKey)
        if !found </span><span class="cov8" title="7">{
                return nil
        }</span>

        <span class="cov3" title="2">if err := active.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">if err := w.storage.Publish(ctx, active.name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">w.activeFiles.Remove(partitionKey)
        return nil</span>
}

func (w *Processor) cleanup(ctx context.Context, watermark time.Time) error <span class="cov8" title="6">{
        w.mu.Lock()
        defer w.mu.Unlock()

        for </span><span class="cov9" title="8">{
                k, v, ok := w.activeFiles.Peek()
                if !ok </span><span class="cov1" title="1">{
                        break</span>
                }
                <span class="cov8" title="7">if !w.strategy.ShouldRotate(v.information, watermark) </span><span class="cov7" title="5">{
                        break</span>
                }
                <span class="cov3" title="2">if err := w.rotate(ctx, k); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to rotate during close: %w", err)
                }</span>
                <span class="cov3" title="2">w.activeFiles.Remove(k)</span>
        }

        <span class="cov8" title="6">return nil</span>
}

func orderByWatermark(a, b activeWriter) bool <span class="cov8" title="7">{
        return a.lastWatermark.Before(b.lastWatermark)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package recordio

import (
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "iter"
        "time"

        "github.com/davidvella/xp/core/partition"
)

// BinaryWriter handles writing binary data with error handling.
type BinaryWriter struct {
        w io.Writer
}

func NewBinaryWriter(w io.Writer) BinaryWriter <span class="cov7" title="16">{
        return BinaryWriter{w: w}
}</span>

func (bw BinaryWriter) WriteString(s string) error <span class="cov10" title="41">{
        if err := binary.Write(bw.w, binary.LittleEndian, uint64(len(s))); err != nil </span><span class="cov3" title="3">{
                return fmt.Errorf("error writing string length: %w", err)
        }</span>
        <span class="cov9" title="38">if _, err := bw.w.Write([]byte(s)); err != nil </span><span class="cov3" title="3">{
                return fmt.Errorf("error writing string content: %w", err)
        }</span>
        <span class="cov9" title="35">return nil</span>
}

func (bw BinaryWriter) WriteInt64(i int64) error <span class="cov7" title="12">{
        return binary.Write(bw.w, binary.LittleEndian, i)
}</span>

func (bw BinaryWriter) WriteBytes(b []byte) error <span class="cov6" title="9">{
        if err := binary.Write(bw.w, binary.LittleEndian, uint64(len(b))); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("error writing bytes length: %w", err)
        }</span>
        <span class="cov6" title="8">if _, err := bw.w.Write(b); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("error writing bytes content: %w", err)
        }</span>
        <span class="cov5" title="7">return nil</span>
}

// BinaryReader handles reading binary data with error handling.
type BinaryReader struct {
        r io.Reader
}

func NewBinaryReader(r io.Reader) BinaryReader <span class="cov7" title="13">{
        return BinaryReader{r: r}
}</span>

func (br BinaryReader) ReadString() (string, error) <span class="cov8" title="25">{
        var length uint64
        if err := binary.Read(br.r, binary.LittleEndian, &amp;length); err != nil </span><span class="cov5" title="7">{
                return "", fmt.Errorf("error reading string length: %w", err)
        }</span>

        <span class="cov8" title="18">bytes := make([]byte, length)
        if _, err := io.ReadFull(br.r, bytes); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error reading string content: %w", err)
        }</span>
        <span class="cov8" title="18">return string(bytes), nil</span>
}

func (br BinaryReader) ReadInt64() (int64, error) <span class="cov5" title="6">{
        var value int64
        err := binary.Read(br.r, binary.LittleEndian, &amp;value)
        return value, err
}</span>

func (br BinaryReader) ReadBytes() ([]byte, error) <span class="cov5" title="6">{
        var length uint64
        if err := binary.Read(br.r, binary.LittleEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading bytes length: %w", err)
        }</span>

        <span class="cov5" title="6">bytes := make([]byte, length)
        if _, err := io.ReadFull(br.r, bytes); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading bytes content: %w", err)
        }</span>
        <span class="cov5" title="6">return bytes, nil</span>
}

// Write writes a single record to the writer.
func Write(w io.Writer, data partition.Record) error <span class="cov7" title="17">{
        if data == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov7" title="16">bw := NewBinaryWriter(w)

        if err := bw.WriteString(data.GetID()); err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("error writing ID: %w", err)
        }</span>

        <span class="cov7" title="14">if err := bw.WriteString(data.GetPartitionKey()); err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("error writing partition key: %w", err)
        }</span>

        <span class="cov7" title="12">if err := bw.WriteInt64(data.GetWatermark().UnixNano()); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("error writing timestamp: %w", err)
        }</span>

        <span class="cov6" title="11">if err := bw.WriteString(data.GetWatermark().Location().String()); err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("error writing timezone: %w", err)
        }</span>

        <span class="cov6" title="9">if err := bw.WriteBytes(data.GetData()); err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("error writing data: %w", err)
        }</span>

        <span class="cov5" title="7">if _, err := w.Write([]byte{'\n'}); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("error writing newline: %w", err)
        }</span>

        <span class="cov5" title="6">return nil</span>
}

// ReadRecord reads a single record from the reader.
func ReadRecord(r io.Reader) (partition.Record, error) <span class="cov7" title="13">{
        br := NewBinaryReader(r)

        id, err := br.ReadString()
        if err != nil </span><span class="cov5" title="7">{
                if errors.Is(err, io.EOF) </span><span class="cov5" title="7">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error reading ID: %w", err)</span>
        }

        <span class="cov5" title="6">partitionKey, err := br.ReadString()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading partition key: %w", err)
        }</span>

        <span class="cov5" title="6">unixNano, err := br.ReadInt64()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading timestamp: %w", err)
        }</span>

        <span class="cov5" title="6">timezone, err := br.ReadString()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading timezone: %w", err)
        }</span>

        <span class="cov5" title="6">loc, err := time.LoadLocation(timezone)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error loading timezone: %w", err)
        }</span>

        <span class="cov5" title="6">timestamp := time.Unix(0, unixNano).In(loc)

        data, err := br.ReadBytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading data: %w", err)
        }</span>

        <span class="cov5" title="6">nl := make([]byte, 1)
        if _, err := io.ReadFull(r, nl); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading newline: %w", err)
        }</span>

        <span class="cov5" title="6">return partition.RecordImpl{
                ID:           id,
                PartitionKey: partitionKey,
                Timestamp:    timestamp,
                Data:         data,
        }, nil</span>
}

// Seq creates an iterator over records.
func Seq(r io.Reader) iter.Seq[partition.Record] <span class="cov5" title="7">{
        return func(yield func(partition.Record) bool) </span><span class="cov5" title="7">{
                for </span><span class="cov7" title="13">{
                        record, err := ReadRecord(r)
                        if err != nil </span><span class="cov5" title="7">{
                                if errors.Is(err, io.EOF) </span><span class="cov5" title="7">{
                                        return
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                        <span class="cov5" title="6">if !yield(record) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// ReadRecords reads all records into a slice.
func ReadRecords(r io.Reader) []partition.Record <span class="cov5" title="7">{
        records := make([]partition.Record, 0, 1)
        for record := range Seq(r) </span><span class="cov5" title="6">{
                records = append(records, record)
        }</span>
        <span class="cov5" title="7">return records</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package local

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
)

// Storage implements Storage using the local filesystem.
type Storage struct {
        pendingDir    string
        publishingDir string
}

func NewLocalStorage(pendingDir, publishingDir string) *Storage <span class="cov10" title="7">{
        return &amp;Storage{
                pendingDir:    pendingDir,
                publishingDir: publishingDir,
        }
}</span>

func (s *Storage) Create(_ context.Context, path string) (io.WriteCloser, error) <span class="cov4" title="2">{
        file, err := os.OpenFile(filepath.Join(s.pendingDir, filepath.Base(path)), os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o600)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open file %s: %w", path, err)
        }</span>
        <span class="cov4" title="2">return file, nil</span>
}

func (s *Storage) Publish(_ context.Context, path string) error <span class="cov4" title="2">{
        newPath := filepath.Join(s.publishingDir, filepath.Base(path))
        return os.Rename(path, newPath)
}</span>

func (s *Storage) List(_ context.Context) ([]string, error) <span class="cov6" title="3">{
        entries, err := os.ReadDir(s.pendingDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">var files []string
        for _, entry := range entries </span><span class="cov7" title="4">{
                if !entry.IsDir() </span><span class="cov6" title="3">{
                        files = append(files, entry.Name())
                }</span>
        }
        <span class="cov6" title="3">return files, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package wal

import (
        "fmt"
        "io"
        "sync"

        "github.com/davidvella/xp/core/partition"
        "github.com/davidvella/xp/core/recordio"
)

type WAL struct {
        mu sync.Mutex
        w  io.WriteCloser
}

func NewWAL(w io.WriteCloser) *WAL <span class="cov0" title="0">{
        return &amp;WAL{w: w}
}</span>

func (w *WAL) Write(rec partition.Record) error <span class="cov10" title="13">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if err := recordio.Write(w.w, rec); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to write record: %w", err)
        }</span>

        <span class="cov9" title="12">return nil</span>
}

func (w *WAL) Close() error <span class="cov3" title="2">{
        w.mu.Lock()
        defer w.mu.Unlock()

        return w.w.Close()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
